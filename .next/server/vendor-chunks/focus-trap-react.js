"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/focus-trap-react";
exports.ids = ["vendor-chunks/focus-trap-react"];
exports.modules = {

/***/ "(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js":
/*!****************************************************************!*\
  !*** ./node_modules/focus-trap-react/dist/focus-trap-react.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar PropTypes = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\nvar _require = __webpack_require__(/*! focus-trap */ \"(ssr)/./node_modules/focus-trap/dist/focus-trap.js\"),\n  createFocusTrap = _require.createFocusTrap;\nvar _require2 = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.js\"),\n  isFocusable = _require2.isFocusable;\nvar FocusTrap = /*#__PURE__*/function (_React$Component) {\n  function FocusTrap(props) {\n    var _this;\n    _classCallCheck(this, FocusTrap);\n    _this = _callSuper(this, FocusTrap, [props]);\n    /**\n     * Gets the node for the given option, which is expected to be an option that\n     *  can be either a DOM node, a string that is a selector to get a node, `false`\n     *  (if a node is explicitly NOT given), or a function that returns any of these\n     *  values.\n     * @param {string} optionName\n     * @returns {undefined | false | HTMLElement | SVGElement} Returns\n     *  `undefined` if the option is not specified; `false` if the option\n     *  resolved to `false` (node explicitly not given); otherwise, the resolved\n     *  DOM node.\n     * @throws {Error} If the option is set, not `false`, and is not, or does not\n     *  resolve to a node.\n     */\n    _defineProperty(_this, \"getNodeForOption\", function (optionName) {\n      var _this$internalOptions;\n      // use internal options first, falling back to original options\n      var optionValue = (_this$internalOptions = this.internalOptions[optionName]) !== null && _this$internalOptions !== void 0 ? _this$internalOptions : this.originalOptions[optionName];\n      if (typeof optionValue === 'function') {\n        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          params[_key - 1] = arguments[_key];\n        }\n        optionValue = optionValue.apply(void 0, params);\n      }\n      if (optionValue === true) {\n        optionValue = undefined; // use default value\n      }\n      if (!optionValue) {\n        if (optionValue === undefined || optionValue === false) {\n          return optionValue;\n        }\n        // else, empty string (invalid), null (invalid), 0 (invalid)\n\n        throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n      }\n      var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n      if (typeof optionValue === 'string') {\n        var _this$getDocument;\n        node = (_this$getDocument = this.getDocument()) === null || _this$getDocument === void 0 ? void 0 : _this$getDocument.querySelector(optionValue); // resolve to node, or null if fails\n        if (!node) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n      }\n      return node;\n    });\n    _this.handleDeactivate = _this.handleDeactivate.bind(_this);\n    _this.handlePostDeactivate = _this.handlePostDeactivate.bind(_this);\n    _this.handleClickOutsideDeactivates = _this.handleClickOutsideDeactivates.bind(_this);\n\n    // focus-trap options used internally when creating the trap\n    _this.internalOptions = {\n      // We need to hijack the returnFocusOnDeactivate option,\n      // because React can move focus into the element before we arrived at\n      // this lifecycle hook (e.g. with autoFocus inputs). So the component\n      // captures the previouslyFocusedElement in componentWillMount,\n      // then (optionally) returns focus to it in componentWillUnmount.\n      returnFocusOnDeactivate: false,\n      // the rest of these are also related to deactivation of the trap, and we\n      //  need to use them and control them as well\n      checkCanReturnFocus: null,\n      onDeactivate: _this.handleDeactivate,\n      onPostDeactivate: _this.handlePostDeactivate,\n      // we need to special-case this setting as well so that we can know if we should\n      //  NOT return focus if the trap gets auto-deactivated as the result of an\n      //  outside click (otherwise, we'll always think we should return focus because\n      //  of how we manage that flag internally here)\n      clickOutsideDeactivates: _this.handleClickOutsideDeactivates\n    };\n\n    // original options provided by the consumer\n    _this.originalOptions = {\n      // because of the above `internalOptions`, we maintain our own flag for\n      //  this option, and default it to `true` because that's focus-trap's default\n      returnFocusOnDeactivate: true,\n      // because of the above `internalOptions`, we keep these separate since\n      //  they're part of the deactivation process which we configure (internally) to\n      //  be shared between focus-trap and focus-trap-react\n      onDeactivate: null,\n      onPostDeactivate: null,\n      checkCanReturnFocus: null,\n      // the user's setting, defaulted to false since focus-trap defaults this to false\n      clickOutsideDeactivates: false\n    };\n    var focusTrapOptions = props.focusTrapOptions;\n    for (var optionName in focusTrapOptions) {\n      if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {\n        continue;\n      }\n      if (optionName === 'returnFocusOnDeactivate' || optionName === 'onDeactivate' || optionName === 'onPostDeactivate' || optionName === 'checkCanReturnFocus' || optionName === 'clickOutsideDeactivates') {\n        _this.originalOptions[optionName] = focusTrapOptions[optionName];\n        continue; // exclude from internalOptions\n      }\n      _this.internalOptions[optionName] = focusTrapOptions[optionName];\n    }\n\n    // if set, `{ target: Node, allowDeactivation: boolean }` where `target` is the outside\n    //  node that was clicked, and `allowDeactivation` is the result of the consumer's\n    //  option (stored in `this.originalOptions.clickOutsideDeactivates`, which may be a\n    //  function) whether to allow or deny auto-deactivation on click on this outside node\n    _this.outsideClick = null;\n\n    // elements from which to create the focus trap on mount; if a child is used\n    //  instead of the `containerElements` prop, we'll get the child's related\n    //  element when the trap renders and then is declared 'mounted'\n    _this.focusTrapElements = props.containerElements || [];\n\n    // now we remember what the currently focused element is, not relying on focus-trap\n    _this.updatePreviousElement();\n    return _this;\n  }\n\n  /**\n   * Gets the configured document.\n   * @returns {Document|undefined} Configured document, falling back to the main\n   *  document, if it exists. During SSR, `undefined` is returned since the\n   *  document doesn't exist.\n   */\n  _inherits(FocusTrap, _React$Component);\n  return _createClass(FocusTrap, [{\n    key: \"getDocument\",\n    value: function getDocument() {\n      // SSR: careful to check if `document` exists before accessing it as a variable\n      return this.props.focusTrapOptions.document || (typeof document !== 'undefined' ? document : undefined);\n    }\n  }, {\n    key: \"getReturnFocusNode\",\n    value: function getReturnFocusNode() {\n      var node = this.getNodeForOption('setReturnFocus', this.previouslyFocusedElement);\n      return node ? node : node === false ? false : this.previouslyFocusedElement;\n    }\n\n    /** Update the previously focused element with the currently focused element. */\n  }, {\n    key: \"updatePreviousElement\",\n    value: function updatePreviousElement() {\n      var currentDocument = this.getDocument();\n      if (currentDocument) {\n        this.previouslyFocusedElement = currentDocument.activeElement;\n      }\n    }\n  }, {\n    key: \"deactivateTrap\",\n    value: function deactivateTrap() {\n      // NOTE: it's possible the focus trap has already been deactivated without our knowing it,\n      //  especially if the user set the `clickOutsideDeactivates: true` option on the trap,\n      //  and the mouse was clicked on some element outside the trap; at that point, focus-trap\n      //  will initiate its auto-deactivation process, which will call our own\n      //  handleDeactivate(), which will call into this method\n      if (!this.focusTrap || !this.focusTrap.active) {\n        return;\n      }\n      this.focusTrap.deactivate({\n        // NOTE: we never let the trap return the focus since we do that ourselves\n        returnFocus: false,\n        // we'll call this in our own post deactivate handler so make sure the trap doesn't\n        //  do it prematurely\n        checkCanReturnFocus: null,\n        // let it call the user's original deactivate handler, if any, instead of\n        //  our own which calls back into this function\n        onDeactivate: this.originalOptions.onDeactivate\n        // NOTE: for post deactivate, don't specify anything so that it calls the\n        //  onPostDeactivate handler specified on `this.internalOptions`\n        //  which will always be our own `handlePostDeactivate()` handler, which\n        //  will finish things off by calling the user's provided onPostDeactivate\n        //  handler, if any, at the right time\n        // onPostDeactivate: NOTHING\n      });\n    }\n  }, {\n    key: \"handleClickOutsideDeactivates\",\n    value: function handleClickOutsideDeactivates(event) {\n      // use consumer's option (or call their handler) as the permission or denial\n      var allowDeactivation = typeof this.originalOptions.clickOutsideDeactivates === 'function' ? this.originalOptions.clickOutsideDeactivates.call(null, event) // call out of context\n      : this.originalOptions.clickOutsideDeactivates; // boolean\n\n      if (allowDeactivation) {\n        // capture the outside target that was clicked so we can use it in the deactivation\n        //  process since the consumer allowed it to cause auto-deactivation\n        this.outsideClick = {\n          target: event.target,\n          allowDeactivation: allowDeactivation\n        };\n      }\n      return allowDeactivation;\n    }\n  }, {\n    key: \"handleDeactivate\",\n    value: function handleDeactivate() {\n      if (this.originalOptions.onDeactivate) {\n        this.originalOptions.onDeactivate.call(null); // call user's handler out of context\n      }\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"handlePostDeactivate\",\n    value: function handlePostDeactivate() {\n      var _this2 = this;\n      var finishDeactivation = function finishDeactivation() {\n        var returnFocusNode = _this2.getReturnFocusNode();\n        var canReturnFocus = !!(\n        // did the consumer allow it?\n\n        _this2.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?\n        returnFocusNode !== null && returnFocusNode !== void 0 && returnFocusNode.focus && (\n        // was there an outside click that allowed deactivation?\n        !_this2.outsideClick ||\n        // did the consumer allow deactivation when the outside node was clicked?\n        _this2.outsideClick.allowDeactivation &&\n        // is the outside node NOT focusable (implying that it did NOT receive focus\n        //  as a result of the click-through) -- in which case do NOT restore focus\n        //  to `returnFocusNode` because focus should remain on the outside node\n        !isFocusable(_this2.outsideClick.target, _this2.internalOptions.tabbableOptions))\n\n        // if no, the restore focus to `returnFocusNode` at this point\n        );\n        var _this2$internalOption = _this2.internalOptions.preventScroll,\n          preventScroll = _this2$internalOption === void 0 ? false : _this2$internalOption;\n        if (canReturnFocus) {\n          // return focus to the element that had focus when the trap was activated\n          returnFocusNode.focus({\n            preventScroll: preventScroll\n          });\n        }\n        if (_this2.originalOptions.onPostDeactivate) {\n          _this2.originalOptions.onPostDeactivate.call(null); // don't call it in context of \"this\"\n        }\n        _this2.outsideClick = null; // reset: no longer needed\n      };\n      if (this.originalOptions.checkCanReturnFocus) {\n        this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()) // call out of context\n        .then(finishDeactivation, finishDeactivation);\n      } else {\n        finishDeactivation();\n      }\n    }\n  }, {\n    key: \"setupFocusTrap\",\n    value: function setupFocusTrap() {\n      if (this.focusTrap) {\n        // trap already exists: it's possible we're in StrictMode and we're being remounted,\n        //  in which case, we will have deactivated the trap when we got unmounted (remember,\n        //  StrictMode, in development, purposely unmounts and remounts components after\n        //  mounting them the first time to make sure they have reusable state,\n        //  @see https://reactjs.org/docs/strict-mode.html#ensuring-reusable-state) so now\n        //  we need to restore the state of the trap according to our component state\n        // NOTE: Strict mode __violates__ assumptions about the `componentWillUnmount()` API\n        //  which clearly states -- even for React 18 -- that, \"Once a component instance is\n        //  unmounted, __it will never be mounted again.__\" (emphasis ours). So when we get\n        //  unmounted, we assume we're gone forever and we deactivate the trap. But then\n        //  we get remounted and we're supposed to restore state. But if you had paused,\n        //  we've now deactivated (we don't know we're amount to get remounted again)\n        //  which means we need to reactivate and then pause. Otherwise, do nothing.\n        if (this.props.active && !this.focusTrap.active) {\n          this.focusTrap.activate();\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      } else {\n        var nodesExist = this.focusTrapElements.some(Boolean);\n        if (nodesExist) {\n          // eslint-disable-next-line react/prop-types -- _createFocusTrap is an internal prop\n          this.focusTrap = this.props._createFocusTrap(this.focusTrapElements, this.internalOptions);\n          if (this.props.active) {\n            this.focusTrap.activate();\n          }\n          if (this.props.paused) {\n            this.focusTrap.pause();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.active) {\n        this.setupFocusTrap();\n      }\n      // else, wait for later activation in case the `focusTrapOptions` will be updated\n      //  again before the trap is activated (e.g. if waiting to know what the document\n      //  object will be, so the Trap must be rendered, but the consumer is waiting to\n      //  activate until they have obtained the document from a ref)\n      //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.focusTrap) {\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrap.updateContainerElements(this.props.containerElements);\n        }\n        var hasActivated = !prevProps.active && this.props.active;\n        var hasDeactivated = prevProps.active && !this.props.active;\n        var hasPaused = !prevProps.paused && this.props.paused;\n        var hasUnpaused = prevProps.paused && !this.props.paused;\n        if (hasActivated) {\n          this.updatePreviousElement();\n          this.focusTrap.activate();\n        }\n        if (hasDeactivated) {\n          this.deactivateTrap();\n          return; // un/pause does nothing on an inactive trap\n        }\n        if (hasPaused) {\n          this.focusTrap.pause();\n        }\n        if (hasUnpaused) {\n          this.focusTrap.unpause();\n        }\n      } else {\n        // NOTE: if we're in `componentDidUpdate` and we don't have a trap yet,\n        //  it either means it shouldn't be active, or it should be but none of\n        //  of given `containerElements` were present in the DOM the last time\n        //  we tried to create the trap\n\n        if (prevProps.containerElements !== this.props.containerElements) {\n          this.focusTrapElements = this.props.containerElements;\n        }\n\n        // don't create the trap unless it should be active in case the consumer\n        //  is still updating `focusTrapOptions`\n        //  @see https://github.com/focus-trap/focus-trap-react/issues/539\n        if (this.props.active) {\n          this.updatePreviousElement();\n          this.setupFocusTrap();\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deactivateTrap();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var child = this.props.children ? React.Children.only(this.props.children) : undefined;\n      if (child) {\n        if (child.type && child.type === React.Fragment) {\n          throw new Error('A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.');\n        }\n        var callbackRef = function callbackRef(element) {\n          var containerElements = _this3.props.containerElements;\n          if (child) {\n            if (typeof child.ref === 'function') {\n              child.ref(element);\n            } else if (child.ref) {\n              child.ref.current = element;\n            }\n          }\n          _this3.focusTrapElements = containerElements ? containerElements : [element];\n        };\n        var childWithRef = React.cloneElement(child, {\n          ref: callbackRef\n        });\n        return childWithRef;\n      }\n      return null;\n    }\n  }]);\n}(React.Component); // support server-side rendering where `Element` will not be defined\nvar ElementType = typeof Element === 'undefined' ? Function : Element;\nFocusTrap.propTypes = {\n  active: PropTypes.bool,\n  paused: PropTypes.bool,\n  focusTrapOptions: PropTypes.shape({\n    document: PropTypes.object,\n    onActivate: PropTypes.func,\n    onPostActivate: PropTypes.func,\n    checkCanFocusTrap: PropTypes.func,\n    onPause: PropTypes.func,\n    onPostPause: PropTypes.func,\n    onUnpause: PropTypes.func,\n    onPostUnpause: PropTypes.func,\n    onDeactivate: PropTypes.func,\n    onPostDeactivate: PropTypes.func,\n    checkCanReturnFocus: PropTypes.func,\n    initialFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    fallbackFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string,\n    // NOTE: does not support `false` as value (or return value from function)\n    PropTypes.func]),\n    escapeDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    clickOutsideDeactivates: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    returnFocusOnDeactivate: PropTypes.bool,\n    setReturnFocus: PropTypes.oneOfType([PropTypes.instanceOf(ElementType), PropTypes.string, PropTypes.bool, PropTypes.func]),\n    allowOutsideClick: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    preventScroll: PropTypes.bool,\n    tabbableOptions: PropTypes.shape({\n      displayCheck: PropTypes.oneOf(['full', 'legacy-full', 'non-zero-area', 'none']),\n      getShadowRoot: PropTypes.oneOfType([PropTypes.bool, PropTypes.func])\n    }),\n    trapStack: PropTypes.array,\n    isKeyForward: PropTypes.func,\n    isKeyBackward: PropTypes.func\n  }),\n  containerElements: PropTypes.arrayOf(PropTypes.instanceOf(ElementType)),\n  // DOM element ONLY\n  children: PropTypes.oneOfType([PropTypes.element,\n  // React element\n  PropTypes.instanceOf(ElementType) // DOM element\n  ])\n\n  // NOTE: _createFocusTrap is internal, for testing purposes only, so we don't\n  //  specify it here. It's expected to be set to the function returned from\n  //  require('focus-trap'), or one with a compatible interface.\n};\nFocusTrap.defaultProps = {\n  active: true,\n  paused: false,\n  focusTrapOptions: {},\n  _createFocusTrap: createFocusTrap\n};\nmodule.exports = FocusTrap;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9jdXMtdHJhcC1yZWFjdC9kaXN0L2ZvY3VzLXRyYXAtcmVhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLCtCQUErQjtBQUMvQiw0Q0FBNEMsdUVBQXVFLG1HQUFtRztBQUN0TixxQ0FBcUMseUdBQXlHO0FBQzlJLHVDQUF1QyxNQUFNLHFGQUFxRixNQUFNLGFBQWEsMkVBQTJFLGFBQWE7QUFDN08sOEJBQThCLCtGQUErRixpREFBaUQ7QUFDOUssMkJBQTJCLHFIQUFxSCxnREFBZ0QsZUFBZSw0Q0FBNEMsMkNBQTJDLGNBQWM7QUFDcFQsaUNBQWlDLGtHQUFrRyw0QkFBNEI7QUFDL0osb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDREQUFZO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBWTtBQUNuQztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLDhDQUE4QztBQUMvRCxvREFBb0Q7QUFDcEQseURBQXlEO0FBQ3pEO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsYUFBYTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0EsMEpBQTBKO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDBDQUEwQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwLXJlYWN0L2Rpc3QvZm9jdXMtdHJhcC1yZWFjdC5qcz81ZjcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF9jYWxsU3VwZXIodCwgbywgZSkgeyByZXR1cm4gbyA9IF9nZXRQcm90b3R5cGVPZihvKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpID8gUmVmbGVjdC5jb25zdHJ1Y3QobywgZSB8fCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpOyB9XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7IGlmIChlICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7IGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7IH1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkgeyBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7IHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTsgfSwgX2dldFByb3RvdHlwZU9mKHQpOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHQsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpOyB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkgeyByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7IHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7IH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdmb2N1cy10cmFwJyksXG4gIGNyZWF0ZUZvY3VzVHJhcCA9IF9yZXF1aXJlLmNyZWF0ZUZvY3VzVHJhcDtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd0YWJiYWJsZScpLFxuICBpc0ZvY3VzYWJsZSA9IF9yZXF1aXJlMi5pc0ZvY3VzYWJsZTtcbnZhciBGb2N1c1RyYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gRm9jdXNUcmFwKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb2N1c1RyYXApO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBGb2N1c1RyYXAsIFtwcm9wc10pO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBvcHRpb24sIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9wdGlvbiB0aGF0XG4gICAgICogIGNhbiBiZSBlaXRoZXIgYSBET00gbm9kZSwgYSBzdHJpbmcgdGhhdCBpcyBhIHNlbGVjdG9yIHRvIGdldCBhIG5vZGUsIGBmYWxzZWBcbiAgICAgKiAgKGlmIGEgbm9kZSBpcyBleHBsaWNpdGx5IE5PVCBnaXZlbiksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFueSBvZiB0aGVzZVxuICAgICAqICB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbk5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgZmFsc2UgfCBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IFJldHVybnNcbiAgICAgKiAgYHVuZGVmaW5lZGAgaWYgdGhlIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkOyBgZmFsc2VgIGlmIHRoZSBvcHRpb25cbiAgICAgKiAgcmVzb2x2ZWQgdG8gYGZhbHNlYCAobm9kZSBleHBsaWNpdGx5IG5vdCBnaXZlbik7IG90aGVyd2lzZSwgdGhlIHJlc29sdmVkXG4gICAgICogIERPTSBub2RlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgb3B0aW9uIGlzIHNldCwgbm90IGBmYWxzZWAsIGFuZCBpcyBub3QsIG9yIGRvZXMgbm90XG4gICAgICogIHJlc29sdmUgdG8gYSBub2RlLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJnZXROb2RlRm9yT3B0aW9uXCIsIGZ1bmN0aW9uIChvcHRpb25OYW1lKSB7XG4gICAgICB2YXIgX3RoaXMkaW50ZXJuYWxPcHRpb25zO1xuICAgICAgLy8gdXNlIGludGVybmFsIG9wdGlvbnMgZmlyc3QsIGZhbGxpbmcgYmFjayB0byBvcmlnaW5hbCBvcHRpb25zXG4gICAgICB2YXIgb3B0aW9uVmFsdWUgPSAoX3RoaXMkaW50ZXJuYWxPcHRpb25zID0gdGhpcy5pbnRlcm5hbE9wdGlvbnNbb3B0aW9uTmFtZV0pICE9PSBudWxsICYmIF90aGlzJGludGVybmFsT3B0aW9ucyAhPT0gdm9pZCAwID8gX3RoaXMkaW50ZXJuYWxPcHRpb25zIDogdGhpcy5vcmlnaW5hbE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIHBhcmFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZS5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgb3B0aW9uVmFsdWUgPSB1bmRlZmluZWQ7IC8vIHVzZSBkZWZhdWx0IHZhbHVlXG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvblZhbHVlKSB7XG4gICAgICAgIGlmIChvcHRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvblZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBvcHRpb25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlLCBlbXB0eSBzdHJpbmcgKGludmFsaWQpLCBudWxsIChpbnZhbGlkKSwgMCAoaW52YWxpZClcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCB3YXMgc3BlY2lmaWVkIGJ1dCB3YXMgbm90IGEgbm9kZSwgb3IgZGlkIG5vdCByZXR1cm4gYSBub2RlXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7IC8vIGNvdWxkIGJlIEhUTUxFbGVtZW50LCBTVkdFbGVtZW50LCBvciBub24tZW1wdHkgc3RyaW5nIGF0IHRoaXMgcG9pbnRcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIF90aGlzJGdldERvY3VtZW50O1xuICAgICAgICBub2RlID0gKF90aGlzJGdldERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCgpKSA9PT0gbnVsbCB8fCBfdGhpcyRnZXREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkZ2V0RG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25WYWx1ZSk7IC8vIHJlc29sdmUgdG8gbm9kZSwgb3IgbnVsbCBpZiBmYWlsc1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCBhcyBzZWxlY3RvciByZWZlcnMgdG8gbm8ga25vd24gbm9kZVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIF90aGlzLmhhbmRsZURlYWN0aXZhdGUgPSBfdGhpcy5oYW5kbGVEZWFjdGl2YXRlLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZVBvc3REZWFjdGl2YXRlID0gX3RoaXMuaGFuZGxlUG9zdERlYWN0aXZhdGUuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMgPSBfdGhpcy5oYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlcy5iaW5kKF90aGlzKTtcblxuICAgIC8vIGZvY3VzLXRyYXAgb3B0aW9ucyB1c2VkIGludGVybmFsbHkgd2hlbiBjcmVhdGluZyB0aGUgdHJhcFxuICAgIF90aGlzLmludGVybmFsT3B0aW9ucyA9IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gaGlqYWNrIHRoZSByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSBvcHRpb24sXG4gICAgICAvLyBiZWNhdXNlIFJlYWN0IGNhbiBtb3ZlIGZvY3VzIGludG8gdGhlIGVsZW1lbnQgYmVmb3JlIHdlIGFycml2ZWQgYXRcbiAgICAgIC8vIHRoaXMgbGlmZWN5Y2xlIGhvb2sgKGUuZy4gd2l0aCBhdXRvRm9jdXMgaW5wdXRzKS4gU28gdGhlIGNvbXBvbmVudFxuICAgICAgLy8gY2FwdHVyZXMgdGhlIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCBpbiBjb21wb25lbnRXaWxsTW91bnQsXG4gICAgICAvLyB0aGVuIChvcHRpb25hbGx5KSByZXR1cm5zIGZvY3VzIHRvIGl0IGluIGNvbXBvbmVudFdpbGxVbm1vdW50LlxuICAgICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IGZhbHNlLFxuICAgICAgLy8gdGhlIHJlc3Qgb2YgdGhlc2UgYXJlIGFsc28gcmVsYXRlZCB0byBkZWFjdGl2YXRpb24gb2YgdGhlIHRyYXAsIGFuZCB3ZVxuICAgICAgLy8gIG5lZWQgdG8gdXNlIHRoZW0gYW5kIGNvbnRyb2wgdGhlbSBhcyB3ZWxsXG4gICAgICBjaGVja0NhblJldHVybkZvY3VzOiBudWxsLFxuICAgICAgb25EZWFjdGl2YXRlOiBfdGhpcy5oYW5kbGVEZWFjdGl2YXRlLFxuICAgICAgb25Qb3N0RGVhY3RpdmF0ZTogX3RoaXMuaGFuZGxlUG9zdERlYWN0aXZhdGUsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNwZWNpYWwtY2FzZSB0aGlzIHNldHRpbmcgYXMgd2VsbCBzbyB0aGF0IHdlIGNhbiBrbm93IGlmIHdlIHNob3VsZFxuICAgICAgLy8gIE5PVCByZXR1cm4gZm9jdXMgaWYgdGhlIHRyYXAgZ2V0cyBhdXRvLWRlYWN0aXZhdGVkIGFzIHRoZSByZXN1bHQgb2YgYW5cbiAgICAgIC8vICBvdXRzaWRlIGNsaWNrIChvdGhlcndpc2UsIHdlJ2xsIGFsd2F5cyB0aGluayB3ZSBzaG91bGQgcmV0dXJuIGZvY3VzIGJlY2F1c2VcbiAgICAgIC8vICBvZiBob3cgd2UgbWFuYWdlIHRoYXQgZmxhZyBpbnRlcm5hbGx5IGhlcmUpXG4gICAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogX3RoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXNcbiAgICB9O1xuXG4gICAgLy8gb3JpZ2luYWwgb3B0aW9ucyBwcm92aWRlZCBieSB0aGUgY29uc3VtZXJcbiAgICBfdGhpcy5vcmlnaW5hbE9wdGlvbnMgPSB7XG4gICAgICAvLyBiZWNhdXNlIG9mIHRoZSBhYm92ZSBgaW50ZXJuYWxPcHRpb25zYCwgd2UgbWFpbnRhaW4gb3VyIG93biBmbGFnIGZvclxuICAgICAgLy8gIHRoaXMgb3B0aW9uLCBhbmQgZGVmYXVsdCBpdCB0byBgdHJ1ZWAgYmVjYXVzZSB0aGF0J3MgZm9jdXMtdHJhcCdzIGRlZmF1bHRcbiAgICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgYWJvdmUgYGludGVybmFsT3B0aW9uc2AsIHdlIGtlZXAgdGhlc2Ugc2VwYXJhdGUgc2luY2VcbiAgICAgIC8vICB0aGV5J3JlIHBhcnQgb2YgdGhlIGRlYWN0aXZhdGlvbiBwcm9jZXNzIHdoaWNoIHdlIGNvbmZpZ3VyZSAoaW50ZXJuYWxseSkgdG9cbiAgICAgIC8vICBiZSBzaGFyZWQgYmV0d2VlbiBmb2N1cy10cmFwIGFuZCBmb2N1cy10cmFwLXJlYWN0XG4gICAgICBvbkRlYWN0aXZhdGU6IG51bGwsXG4gICAgICBvblBvc3REZWFjdGl2YXRlOiBudWxsLFxuICAgICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogbnVsbCxcbiAgICAgIC8vIHRoZSB1c2VyJ3Mgc2V0dGluZywgZGVmYXVsdGVkIHRvIGZhbHNlIHNpbmNlIGZvY3VzLXRyYXAgZGVmYXVsdHMgdGhpcyB0byBmYWxzZVxuICAgICAgY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZm9jdXNUcmFwT3B0aW9ucyA9IHByb3BzLmZvY3VzVHJhcE9wdGlvbnM7XG4gICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBmb2N1c1RyYXBPcHRpb25zKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb2N1c1RyYXBPcHRpb25zLCBvcHRpb25OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25OYW1lID09PSAncmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUnIHx8IG9wdGlvbk5hbWUgPT09ICdvbkRlYWN0aXZhdGUnIHx8IG9wdGlvbk5hbWUgPT09ICdvblBvc3REZWFjdGl2YXRlJyB8fCBvcHRpb25OYW1lID09PSAnY2hlY2tDYW5SZXR1cm5Gb2N1cycgfHwgb3B0aW9uTmFtZSA9PT0gJ2NsaWNrT3V0c2lkZURlYWN0aXZhdGVzJykge1xuICAgICAgICBfdGhpcy5vcmlnaW5hbE9wdGlvbnNbb3B0aW9uTmFtZV0gPSBmb2N1c1RyYXBPcHRpb25zW29wdGlvbk5hbWVdO1xuICAgICAgICBjb250aW51ZTsgLy8gZXhjbHVkZSBmcm9tIGludGVybmFsT3B0aW9uc1xuICAgICAgfVxuICAgICAgX3RoaXMuaW50ZXJuYWxPcHRpb25zW29wdGlvbk5hbWVdID0gZm9jdXNUcmFwT3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgICB9XG5cbiAgICAvLyBpZiBzZXQsIGB7IHRhcmdldDogTm9kZSwgYWxsb3dEZWFjdGl2YXRpb246IGJvb2xlYW4gfWAgd2hlcmUgYHRhcmdldGAgaXMgdGhlIG91dHNpZGVcbiAgICAvLyAgbm9kZSB0aGF0IHdhcyBjbGlja2VkLCBhbmQgYGFsbG93RGVhY3RpdmF0aW9uYCBpcyB0aGUgcmVzdWx0IG9mIHRoZSBjb25zdW1lcidzXG4gICAgLy8gIG9wdGlvbiAoc3RvcmVkIGluIGB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jbGlja091dHNpZGVEZWFjdGl2YXRlc2AsIHdoaWNoIG1heSBiZSBhXG4gICAgLy8gIGZ1bmN0aW9uKSB3aGV0aGVyIHRvIGFsbG93IG9yIGRlbnkgYXV0by1kZWFjdGl2YXRpb24gb24gY2xpY2sgb24gdGhpcyBvdXRzaWRlIG5vZGVcbiAgICBfdGhpcy5vdXRzaWRlQ2xpY2sgPSBudWxsO1xuXG4gICAgLy8gZWxlbWVudHMgZnJvbSB3aGljaCB0byBjcmVhdGUgdGhlIGZvY3VzIHRyYXAgb24gbW91bnQ7IGlmIGEgY2hpbGQgaXMgdXNlZFxuICAgIC8vICBpbnN0ZWFkIG9mIHRoZSBgY29udGFpbmVyRWxlbWVudHNgIHByb3AsIHdlJ2xsIGdldCB0aGUgY2hpbGQncyByZWxhdGVkXG4gICAgLy8gIGVsZW1lbnQgd2hlbiB0aGUgdHJhcCByZW5kZXJzIGFuZCB0aGVuIGlzIGRlY2xhcmVkICdtb3VudGVkJ1xuICAgIF90aGlzLmZvY3VzVHJhcEVsZW1lbnRzID0gcHJvcHMuY29udGFpbmVyRWxlbWVudHMgfHwgW107XG5cbiAgICAvLyBub3cgd2UgcmVtZW1iZXIgd2hhdCB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCBpcywgbm90IHJlbHlpbmcgb24gZm9jdXMtdHJhcFxuICAgIF90aGlzLnVwZGF0ZVByZXZpb3VzRWxlbWVudCgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWd1cmVkIGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyB7RG9jdW1lbnR8dW5kZWZpbmVkfSBDb25maWd1cmVkIGRvY3VtZW50LCBmYWxsaW5nIGJhY2sgdG8gdGhlIG1haW5cbiAgICogIGRvY3VtZW50LCBpZiBpdCBleGlzdHMuIER1cmluZyBTU1IsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHNpbmNlIHRoZVxuICAgKiAgZG9jdW1lbnQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIF9pbmhlcml0cyhGb2N1c1RyYXAsIF9SZWFjdCRDb21wb25lbnQpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZvY3VzVHJhcCwgW3tcbiAgICBrZXk6IFwiZ2V0RG9jdW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgICAvLyBTU1I6IGNhcmVmdWwgdG8gY2hlY2sgaWYgYGRvY3VtZW50YCBleGlzdHMgYmVmb3JlIGFjY2Vzc2luZyBpdCBhcyBhIHZhcmlhYmxlXG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5mb2N1c1RyYXBPcHRpb25zLmRvY3VtZW50IHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZXR1cm5Gb2N1c05vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmV0dXJuRm9jdXNOb2RlKCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGVGb3JPcHRpb24oJ3NldFJldHVybkZvY3VzJywgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgcmV0dXJuIG5vZGUgPyBub2RlIDogbm9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRoaXMucHJldmlvdXNseUZvY3VzZWRFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhlIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IHdpdGggdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQuICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUHJldmlvdXNFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVByZXZpb3VzRWxlbWVudCgpIHtcbiAgICAgIHZhciBjdXJyZW50RG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KCk7XG4gICAgICBpZiAoY3VycmVudERvY3VtZW50KSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gY3VycmVudERvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlYWN0aXZhdGVUcmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYWN0aXZhdGVUcmFwKCkge1xuICAgICAgLy8gTk9URTogaXQncyBwb3NzaWJsZSB0aGUgZm9jdXMgdHJhcCBoYXMgYWxyZWFkeSBiZWVuIGRlYWN0aXZhdGVkIHdpdGhvdXQgb3VyIGtub3dpbmcgaXQsXG4gICAgICAvLyAgZXNwZWNpYWxseSBpZiB0aGUgdXNlciBzZXQgdGhlIGBjbGlja091dHNpZGVEZWFjdGl2YXRlczogdHJ1ZWAgb3B0aW9uIG9uIHRoZSB0cmFwLFxuICAgICAgLy8gIGFuZCB0aGUgbW91c2Ugd2FzIGNsaWNrZWQgb24gc29tZSBlbGVtZW50IG91dHNpZGUgdGhlIHRyYXA7IGF0IHRoYXQgcG9pbnQsIGZvY3VzLXRyYXBcbiAgICAgIC8vICB3aWxsIGluaXRpYXRlIGl0cyBhdXRvLWRlYWN0aXZhdGlvbiBwcm9jZXNzLCB3aGljaCB3aWxsIGNhbGwgb3VyIG93blxuICAgICAgLy8gIGhhbmRsZURlYWN0aXZhdGUoKSwgd2hpY2ggd2lsbCBjYWxsIGludG8gdGhpcyBtZXRob2RcbiAgICAgIGlmICghdGhpcy5mb2N1c1RyYXAgfHwgIXRoaXMuZm9jdXNUcmFwLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZvY3VzVHJhcC5kZWFjdGl2YXRlKHtcbiAgICAgICAgLy8gTk9URTogd2UgbmV2ZXIgbGV0IHRoZSB0cmFwIHJldHVybiB0aGUgZm9jdXMgc2luY2Ugd2UgZG8gdGhhdCBvdXJzZWx2ZXNcbiAgICAgICAgcmV0dXJuRm9jdXM6IGZhbHNlLFxuICAgICAgICAvLyB3ZSdsbCBjYWxsIHRoaXMgaW4gb3VyIG93biBwb3N0IGRlYWN0aXZhdGUgaGFuZGxlciBzbyBtYWtlIHN1cmUgdGhlIHRyYXAgZG9lc24ndFxuICAgICAgICAvLyAgZG8gaXQgcHJlbWF0dXJlbHlcbiAgICAgICAgY2hlY2tDYW5SZXR1cm5Gb2N1czogbnVsbCxcbiAgICAgICAgLy8gbGV0IGl0IGNhbGwgdGhlIHVzZXIncyBvcmlnaW5hbCBkZWFjdGl2YXRlIGhhbmRsZXIsIGlmIGFueSwgaW5zdGVhZCBvZlxuICAgICAgICAvLyAgb3VyIG93biB3aGljaCBjYWxscyBiYWNrIGludG8gdGhpcyBmdW5jdGlvblxuICAgICAgICBvbkRlYWN0aXZhdGU6IHRoaXMub3JpZ2luYWxPcHRpb25zLm9uRGVhY3RpdmF0ZVxuICAgICAgICAvLyBOT1RFOiBmb3IgcG9zdCBkZWFjdGl2YXRlLCBkb24ndCBzcGVjaWZ5IGFueXRoaW5nIHNvIHRoYXQgaXQgY2FsbHMgdGhlXG4gICAgICAgIC8vICBvblBvc3REZWFjdGl2YXRlIGhhbmRsZXIgc3BlY2lmaWVkIG9uIGB0aGlzLmludGVybmFsT3B0aW9uc2BcbiAgICAgICAgLy8gIHdoaWNoIHdpbGwgYWx3YXlzIGJlIG91ciBvd24gYGhhbmRsZVBvc3REZWFjdGl2YXRlKClgIGhhbmRsZXIsIHdoaWNoXG4gICAgICAgIC8vICB3aWxsIGZpbmlzaCB0aGluZ3Mgb2ZmIGJ5IGNhbGxpbmcgdGhlIHVzZXIncyBwcm92aWRlZCBvblBvc3REZWFjdGl2YXRlXG4gICAgICAgIC8vICBoYW5kbGVyLCBpZiBhbnksIGF0IHRoZSByaWdodCB0aW1lXG4gICAgICAgIC8vIG9uUG9zdERlYWN0aXZhdGU6IE5PVEhJTkdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDbGlja091dHNpZGVEZWFjdGl2YXRlcyhldmVudCkge1xuICAgICAgLy8gdXNlIGNvbnN1bWVyJ3Mgb3B0aW9uIChvciBjYWxsIHRoZWlyIGhhbmRsZXIpIGFzIHRoZSBwZXJtaXNzaW9uIG9yIGRlbmlhbFxuICAgICAgdmFyIGFsbG93RGVhY3RpdmF0aW9uID0gdHlwZW9mIHRoaXMub3JpZ2luYWxPcHRpb25zLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzID09PSAnZnVuY3Rpb24nID8gdGhpcy5vcmlnaW5hbE9wdGlvbnMuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMuY2FsbChudWxsLCBldmVudCkgLy8gY2FsbCBvdXQgb2YgY29udGV4dFxuICAgICAgOiB0aGlzLm9yaWdpbmFsT3B0aW9ucy5jbGlja091dHNpZGVEZWFjdGl2YXRlczsgLy8gYm9vbGVhblxuXG4gICAgICBpZiAoYWxsb3dEZWFjdGl2YXRpb24pIHtcbiAgICAgICAgLy8gY2FwdHVyZSB0aGUgb3V0c2lkZSB0YXJnZXQgdGhhdCB3YXMgY2xpY2tlZCBzbyB3ZSBjYW4gdXNlIGl0IGluIHRoZSBkZWFjdGl2YXRpb25cbiAgICAgICAgLy8gIHByb2Nlc3Mgc2luY2UgdGhlIGNvbnN1bWVyIGFsbG93ZWQgaXQgdG8gY2F1c2UgYXV0by1kZWFjdGl2YXRpb25cbiAgICAgICAgdGhpcy5vdXRzaWRlQ2xpY2sgPSB7XG4gICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgYWxsb3dEZWFjdGl2YXRpb246IGFsbG93RGVhY3RpdmF0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsb3dEZWFjdGl2YXRpb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURlYWN0aXZhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRGVhY3RpdmF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9yaWdpbmFsT3B0aW9ucy5vbkRlYWN0aXZhdGUpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE9wdGlvbnMub25EZWFjdGl2YXRlLmNhbGwobnVsbCk7IC8vIGNhbGwgdXNlcidzIGhhbmRsZXIgb3V0IG9mIGNvbnRleHRcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVhY3RpdmF0ZVRyYXAoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlUG9zdERlYWN0aXZhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUG9zdERlYWN0aXZhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBmaW5pc2hEZWFjdGl2YXRpb24gPSBmdW5jdGlvbiBmaW5pc2hEZWFjdGl2YXRpb24oKSB7XG4gICAgICAgIHZhciByZXR1cm5Gb2N1c05vZGUgPSBfdGhpczIuZ2V0UmV0dXJuRm9jdXNOb2RlKCk7XG4gICAgICAgIHZhciBjYW5SZXR1cm5Gb2N1cyA9ICEhKFxuICAgICAgICAvLyBkaWQgdGhlIGNvbnN1bWVyIGFsbG93IGl0P1xuXG4gICAgICAgIF90aGlzMi5vcmlnaW5hbE9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGUgJiYgLy8gY2FuIHdlIGFjdHVhbGx5IGZvY3VzIHRoZSBub2RlP1xuICAgICAgICByZXR1cm5Gb2N1c05vZGUgIT09IG51bGwgJiYgcmV0dXJuRm9jdXNOb2RlICE9PSB2b2lkIDAgJiYgcmV0dXJuRm9jdXNOb2RlLmZvY3VzICYmIChcbiAgICAgICAgLy8gd2FzIHRoZXJlIGFuIG91dHNpZGUgY2xpY2sgdGhhdCBhbGxvd2VkIGRlYWN0aXZhdGlvbj9cbiAgICAgICAgIV90aGlzMi5vdXRzaWRlQ2xpY2sgfHxcbiAgICAgICAgLy8gZGlkIHRoZSBjb25zdW1lciBhbGxvdyBkZWFjdGl2YXRpb24gd2hlbiB0aGUgb3V0c2lkZSBub2RlIHdhcyBjbGlja2VkP1xuICAgICAgICBfdGhpczIub3V0c2lkZUNsaWNrLmFsbG93RGVhY3RpdmF0aW9uICYmXG4gICAgICAgIC8vIGlzIHRoZSBvdXRzaWRlIG5vZGUgTk9UIGZvY3VzYWJsZSAoaW1wbHlpbmcgdGhhdCBpdCBkaWQgTk9UIHJlY2VpdmUgZm9jdXNcbiAgICAgICAgLy8gIGFzIGEgcmVzdWx0IG9mIHRoZSBjbGljay10aHJvdWdoKSAtLSBpbiB3aGljaCBjYXNlIGRvIE5PVCByZXN0b3JlIGZvY3VzXG4gICAgICAgIC8vICB0byBgcmV0dXJuRm9jdXNOb2RlYCBiZWNhdXNlIGZvY3VzIHNob3VsZCByZW1haW4gb24gdGhlIG91dHNpZGUgbm9kZVxuICAgICAgICAhaXNGb2N1c2FibGUoX3RoaXMyLm91dHNpZGVDbGljay50YXJnZXQsIF90aGlzMi5pbnRlcm5hbE9wdGlvbnMudGFiYmFibGVPcHRpb25zKSlcblxuICAgICAgICAvLyBpZiBubywgdGhlIHJlc3RvcmUgZm9jdXMgdG8gYHJldHVybkZvY3VzTm9kZWAgYXQgdGhpcyBwb2ludFxuICAgICAgICApO1xuICAgICAgICB2YXIgX3RoaXMyJGludGVybmFsT3B0aW9uID0gX3RoaXMyLmludGVybmFsT3B0aW9ucy5wcmV2ZW50U2Nyb2xsLFxuICAgICAgICAgIHByZXZlbnRTY3JvbGwgPSBfdGhpczIkaW50ZXJuYWxPcHRpb24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3RoaXMyJGludGVybmFsT3B0aW9uO1xuICAgICAgICBpZiAoY2FuUmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAvLyByZXR1cm4gZm9jdXMgdG8gdGhlIGVsZW1lbnQgdGhhdCBoYWQgZm9jdXMgd2hlbiB0aGUgdHJhcCB3YXMgYWN0aXZhdGVkXG4gICAgICAgICAgcmV0dXJuRm9jdXNOb2RlLmZvY3VzKHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHByZXZlbnRTY3JvbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLm9yaWdpbmFsT3B0aW9ucy5vblBvc3REZWFjdGl2YXRlKSB7XG4gICAgICAgICAgX3RoaXMyLm9yaWdpbmFsT3B0aW9ucy5vblBvc3REZWFjdGl2YXRlLmNhbGwobnVsbCk7IC8vIGRvbid0IGNhbGwgaXQgaW4gY29udGV4dCBvZiBcInRoaXNcIlxuICAgICAgICB9XG4gICAgICAgIF90aGlzMi5vdXRzaWRlQ2xpY2sgPSBudWxsOyAvLyByZXNldDogbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLm9yaWdpbmFsT3B0aW9ucy5jaGVja0NhblJldHVybkZvY3VzKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxPcHRpb25zLmNoZWNrQ2FuUmV0dXJuRm9jdXMuY2FsbChudWxsLCB0aGlzLmdldFJldHVybkZvY3VzTm9kZSgpKSAvLyBjYWxsIG91dCBvZiBjb250ZXh0XG4gICAgICAgIC50aGVuKGZpbmlzaERlYWN0aXZhdGlvbiwgZmluaXNoRGVhY3RpdmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaERlYWN0aXZhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXR1cEZvY3VzVHJhcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEZvY3VzVHJhcCgpIHtcbiAgICAgIGlmICh0aGlzLmZvY3VzVHJhcCkge1xuICAgICAgICAvLyB0cmFwIGFscmVhZHkgZXhpc3RzOiBpdCdzIHBvc3NpYmxlIHdlJ3JlIGluIFN0cmljdE1vZGUgYW5kIHdlJ3JlIGJlaW5nIHJlbW91bnRlZCxcbiAgICAgICAgLy8gIGluIHdoaWNoIGNhc2UsIHdlIHdpbGwgaGF2ZSBkZWFjdGl2YXRlZCB0aGUgdHJhcCB3aGVuIHdlIGdvdCB1bm1vdW50ZWQgKHJlbWVtYmVyLFxuICAgICAgICAvLyAgU3RyaWN0TW9kZSwgaW4gZGV2ZWxvcG1lbnQsIHB1cnBvc2VseSB1bm1vdW50cyBhbmQgcmVtb3VudHMgY29tcG9uZW50cyBhZnRlclxuICAgICAgICAvLyAgbW91bnRpbmcgdGhlbSB0aGUgZmlyc3QgdGltZSB0byBtYWtlIHN1cmUgdGhleSBoYXZlIHJldXNhYmxlIHN0YXRlLFxuICAgICAgICAvLyAgQHNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3Mvc3RyaWN0LW1vZGUuaHRtbCNlbnN1cmluZy1yZXVzYWJsZS1zdGF0ZSkgc28gbm93XG4gICAgICAgIC8vICB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSB0cmFwIGFjY29yZGluZyB0byBvdXIgY29tcG9uZW50IHN0YXRlXG4gICAgICAgIC8vIE5PVEU6IFN0cmljdCBtb2RlIF9fdmlvbGF0ZXNfXyBhc3N1bXB0aW9ucyBhYm91dCB0aGUgYGNvbXBvbmVudFdpbGxVbm1vdW50KClgIEFQSVxuICAgICAgICAvLyAgd2hpY2ggY2xlYXJseSBzdGF0ZXMgLS0gZXZlbiBmb3IgUmVhY3QgMTggLS0gdGhhdCwgXCJPbmNlIGEgY29tcG9uZW50IGluc3RhbmNlIGlzXG4gICAgICAgIC8vICB1bm1vdW50ZWQsIF9faXQgd2lsbCBuZXZlciBiZSBtb3VudGVkIGFnYWluLl9fXCIgKGVtcGhhc2lzIG91cnMpLiBTbyB3aGVuIHdlIGdldFxuICAgICAgICAvLyAgdW5tb3VudGVkLCB3ZSBhc3N1bWUgd2UncmUgZ29uZSBmb3JldmVyIGFuZCB3ZSBkZWFjdGl2YXRlIHRoZSB0cmFwLiBCdXQgdGhlblxuICAgICAgICAvLyAgd2UgZ2V0IHJlbW91bnRlZCBhbmQgd2UncmUgc3VwcG9zZWQgdG8gcmVzdG9yZSBzdGF0ZS4gQnV0IGlmIHlvdSBoYWQgcGF1c2VkLFxuICAgICAgICAvLyAgd2UndmUgbm93IGRlYWN0aXZhdGVkICh3ZSBkb24ndCBrbm93IHdlJ3JlIGFtb3VudCB0byBnZXQgcmVtb3VudGVkIGFnYWluKVxuICAgICAgICAvLyAgd2hpY2ggbWVhbnMgd2UgbmVlZCB0byByZWFjdGl2YXRlIGFuZCB0aGVuIHBhdXNlLiBPdGhlcndpc2UsIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmFjdGl2ZSAmJiAhdGhpcy5mb2N1c1RyYXAuYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm9kZXNFeGlzdCA9IHRoaXMuZm9jdXNUcmFwRWxlbWVudHMuc29tZShCb29sZWFuKTtcbiAgICAgICAgaWYgKG5vZGVzRXhpc3QpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlcyAtLSBfY3JlYXRlRm9jdXNUcmFwIGlzIGFuIGludGVybmFsIHByb3BcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcCA9IHRoaXMucHJvcHMuX2NyZWF0ZUZvY3VzVHJhcCh0aGlzLmZvY3VzVHJhcEVsZW1lbnRzLCB0aGlzLmludGVybmFsT3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5wYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuc2V0dXBGb2N1c1RyYXAoKTtcbiAgICAgIH1cbiAgICAgIC8vIGVsc2UsIHdhaXQgZm9yIGxhdGVyIGFjdGl2YXRpb24gaW4gY2FzZSB0aGUgYGZvY3VzVHJhcE9wdGlvbnNgIHdpbGwgYmUgdXBkYXRlZFxuICAgICAgLy8gIGFnYWluIGJlZm9yZSB0aGUgdHJhcCBpcyBhY3RpdmF0ZWQgKGUuZy4gaWYgd2FpdGluZyB0byBrbm93IHdoYXQgdGhlIGRvY3VtZW50XG4gICAgICAvLyAgb2JqZWN0IHdpbGwgYmUsIHNvIHRoZSBUcmFwIG11c3QgYmUgcmVuZGVyZWQsIGJ1dCB0aGUgY29uc3VtZXIgaXMgd2FpdGluZyB0b1xuICAgICAgLy8gIGFjdGl2YXRlIHVudGlsIHRoZXkgaGF2ZSBvYnRhaW5lZCB0aGUgZG9jdW1lbnQgZnJvbSBhIHJlZilcbiAgICAgIC8vICBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtcmVhY3QvaXNzdWVzLzUzOVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgaWYgKHRoaXMuZm9jdXNUcmFwKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMuY29udGFpbmVyRWxlbWVudHMgIT09IHRoaXMucHJvcHMuY29udGFpbmVyRWxlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC51cGRhdGVDb250YWluZXJFbGVtZW50cyh0aGlzLnByb3BzLmNvbnRhaW5lckVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzQWN0aXZhdGVkID0gIXByZXZQcm9wcy5hY3RpdmUgJiYgdGhpcy5wcm9wcy5hY3RpdmU7XG4gICAgICAgIHZhciBoYXNEZWFjdGl2YXRlZCA9IHByZXZQcm9wcy5hY3RpdmUgJiYgIXRoaXMucHJvcHMuYWN0aXZlO1xuICAgICAgICB2YXIgaGFzUGF1c2VkID0gIXByZXZQcm9wcy5wYXVzZWQgJiYgdGhpcy5wcm9wcy5wYXVzZWQ7XG4gICAgICAgIHZhciBoYXNVbnBhdXNlZCA9IHByZXZQcm9wcy5wYXVzZWQgJiYgIXRoaXMucHJvcHMucGF1c2VkO1xuICAgICAgICBpZiAoaGFzQWN0aXZhdGVkKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWFjdGl2YXRlZCkge1xuICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZVRyYXAoKTtcbiAgICAgICAgICByZXR1cm47IC8vIHVuL3BhdXNlIGRvZXMgbm90aGluZyBvbiBhbiBpbmFjdGl2ZSB0cmFwXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1BhdXNlZCkge1xuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1VucGF1c2VkKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXAudW5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOT1RFOiBpZiB3ZSdyZSBpbiBgY29tcG9uZW50RGlkVXBkYXRlYCBhbmQgd2UgZG9uJ3QgaGF2ZSBhIHRyYXAgeWV0LFxuICAgICAgICAvLyAgaXQgZWl0aGVyIG1lYW5zIGl0IHNob3VsZG4ndCBiZSBhY3RpdmUsIG9yIGl0IHNob3VsZCBiZSBidXQgbm9uZSBvZlxuICAgICAgICAvLyAgb2YgZ2l2ZW4gYGNvbnRhaW5lckVsZW1lbnRzYCB3ZXJlIHByZXNlbnQgaW4gdGhlIERPTSB0aGUgbGFzdCB0aW1lXG4gICAgICAgIC8vICB3ZSB0cmllZCB0byBjcmVhdGUgdGhlIHRyYXBcblxuICAgICAgICBpZiAocHJldlByb3BzLmNvbnRhaW5lckVsZW1lbnRzICE9PSB0aGlzLnByb3BzLmNvbnRhaW5lckVsZW1lbnRzKSB7XG4gICAgICAgICAgdGhpcy5mb2N1c1RyYXBFbGVtZW50cyA9IHRoaXMucHJvcHMuY29udGFpbmVyRWxlbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb24ndCBjcmVhdGUgdGhlIHRyYXAgdW5sZXNzIGl0IHNob3VsZCBiZSBhY3RpdmUgaW4gY2FzZSB0aGUgY29uc3VtZXJcbiAgICAgICAgLy8gIGlzIHN0aWxsIHVwZGF0aW5nIGBmb2N1c1RyYXBPcHRpb25zYFxuICAgICAgICAvLyAgQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZm9jdXMtdHJhcC9mb2N1cy10cmFwLXJlYWN0L2lzc3Vlcy81MzlcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuYWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVQcmV2aW91c0VsZW1lbnQoKTtcbiAgICAgICAgICB0aGlzLnNldHVwRm9jdXNUcmFwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLmRlYWN0aXZhdGVUcmFwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMucHJvcHMuY2hpbGRyZW4gPyBSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlICYmIGNoaWxkLnR5cGUgPT09IFJlYWN0LkZyYWdtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGZvY3VzLXRyYXAgY2Fubm90IHVzZSBhIEZyYWdtZW50IGFzIGl0cyBjaGlsZCBjb250YWluZXIuIFRyeSByZXBsYWNpbmcgaXQgd2l0aCBhIDxkaXY+IGVsZW1lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrUmVmID0gZnVuY3Rpb24gY2FsbGJhY2tSZWYoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBjb250YWluZXJFbGVtZW50cyA9IF90aGlzMy5wcm9wcy5jb250YWluZXJFbGVtZW50cztcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlZihlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQucmVmKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlZi5jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMzLmZvY3VzVHJhcEVsZW1lbnRzID0gY29udGFpbmVyRWxlbWVudHMgPyBjb250YWluZXJFbGVtZW50cyA6IFtlbGVtZW50XTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoaWxkV2l0aFJlZiA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICAgIHJlZjogY2FsbGJhY2tSZWZcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGlsZFdpdGhSZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcbn0oUmVhY3QuQ29tcG9uZW50KTsgLy8gc3VwcG9ydCBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgd2hlcmUgYEVsZW1lbnRgIHdpbGwgbm90IGJlIGRlZmluZWRcbnZhciBFbGVtZW50VHlwZSA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJyA/IEZ1bmN0aW9uIDogRWxlbWVudDtcbkZvY3VzVHJhcC5wcm9wVHlwZXMgPSB7XG4gIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gIHBhdXNlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGZvY3VzVHJhcE9wdGlvbnM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZG9jdW1lbnQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgb25BY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Qb3N0QWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIGNoZWNrQ2FuRm9jdXNUcmFwOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBvc3RQYXVzZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25VbnBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBvc3RVbnBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkRlYWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUG9zdERlYWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIGluaXRpYWxGb2N1czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmluc3RhbmNlT2YoRWxlbWVudFR5cGUpLCBQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBmYWxsYmFja0ZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgLy8gTk9URTogZG9lcyBub3Qgc3VwcG9ydCBgZmFsc2VgIGFzIHZhbHVlIChvciByZXR1cm4gdmFsdWUgZnJvbSBmdW5jdGlvbilcbiAgICBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGVzY2FwZURlYWN0aXZhdGVzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBjbGlja091dHNpZGVEZWFjdGl2YXRlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IFByb3BUeXBlcy5ib29sLFxuICAgIHNldFJldHVybkZvY3VzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihFbGVtZW50VHlwZSksIFByb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5ib29sLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGFsbG93T3V0c2lkZUNsaWNrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBwcmV2ZW50U2Nyb2xsOiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0YWJiYWJsZU9wdGlvbnM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBkaXNwbGF5Q2hlY2s6IFByb3BUeXBlcy5vbmVPZihbJ2Z1bGwnLCAnbGVnYWN5LWZ1bGwnLCAnbm9uLXplcm8tYXJlYScsICdub25lJ10pLFxuICAgICAgZ2V0U2hhZG93Um9vdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5mdW5jXSlcbiAgICB9KSxcbiAgICB0cmFwU3RhY2s6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpc0tleUZvcndhcmQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIGlzS2V5QmFja3dhcmQ6IFByb3BUeXBlcy5mdW5jXG4gIH0pLFxuICBjb250YWluZXJFbGVtZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLmluc3RhbmNlT2YoRWxlbWVudFR5cGUpKSxcbiAgLy8gRE9NIGVsZW1lbnQgT05MWVxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQsXG4gIC8vIFJlYWN0IGVsZW1lbnRcbiAgUHJvcFR5cGVzLmluc3RhbmNlT2YoRWxlbWVudFR5cGUpIC8vIERPTSBlbGVtZW50XG4gIF0pXG5cbiAgLy8gTk9URTogX2NyZWF0ZUZvY3VzVHJhcCBpcyBpbnRlcm5hbCwgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seSwgc28gd2UgZG9uJ3RcbiAgLy8gIHNwZWNpZnkgaXQgaGVyZS4gSXQncyBleHBlY3RlZCB0byBiZSBzZXQgdG8gdGhlIGZ1bmN0aW9uIHJldHVybmVkIGZyb21cbiAgLy8gIHJlcXVpcmUoJ2ZvY3VzLXRyYXAnKSwgb3Igb25lIHdpdGggYSBjb21wYXRpYmxlIGludGVyZmFjZS5cbn07XG5Gb2N1c1RyYXAuZGVmYXVsdFByb3BzID0ge1xuICBhY3RpdmU6IHRydWUsXG4gIHBhdXNlZDogZmFsc2UsXG4gIGZvY3VzVHJhcE9wdGlvbnM6IHt9LFxuICBfY3JlYXRlRm9jdXNUcmFwOiBjcmVhdGVGb2N1c1RyYXBcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEZvY3VzVHJhcDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/focus-trap-react/dist/focus-trap-react.js\n");

/***/ })

};
;